---
phase: 11-insurer-matching-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/insurer_matcher.py
  - app/schemas/matching.py
autonomous: true

must_haves:
  truths:
    - "Articles clearly mentioning an insurer by name or search_term are matched deterministically without AI"
    - "Portuguese accented characters (SulAmerica vs SulAmerica) do not prevent matching"
    - "Short insurer names (e.g. 'Porto', 'Liberty') do not produce false positive substring matches"
    - "An article mentioning two insurer names returns both insurer IDs"
    - "An article matching no insurer returns an empty list with method 'unmatched'"
  artifacts:
    - path: "app/services/insurer_matcher.py"
      provides: "InsurerMatcher class with deterministic_match and match_article methods"
      min_lines: 80
    - path: "app/schemas/matching.py"
      provides: "MatchResult Pydantic model"
      exports: ["MatchResult", "MatchMethod"]
  key_links:
    - from: "app/services/insurer_matcher.py"
      to: "app/models/insurer.py"
      via: "imports Insurer model for type hints"
      pattern: "from app\\.models\\.insurer import Insurer"
    - from: "app/services/insurer_matcher.py"
      to: "app/schemas/matching.py"
      via: "imports MatchResult for return type"
      pattern: "from app\\.schemas\\.matching import MatchResult"
---

<objective>
Create the deterministic insurer matching service and its Pydantic schema.

Purpose: The deterministic matcher handles ~80% of article-to-insurer assignments using fast string matching against insurer names and search_terms, avoiding AI costs for clear cases. This is the foundation that Plan 02 (AI disambiguation) builds on.

Output: `app/services/insurer_matcher.py` with InsurerMatcher class and `app/schemas/matching.py` with MatchResult schema.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-insurer-matching-pipeline/11-RESEARCH.md
@app/models/insurer.py
@app/models/news_item.py
@app/schemas/classification.py
@app/services/classifier.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MatchResult schema</name>
  <files>app/schemas/matching.py</files>
  <action>
Create `app/schemas/matching.py` with:

1. **MatchMethod** — string enum with values:
   - `deterministic_single` — exactly one insurer matched by name/search_term
   - `deterministic_multi` — 2-3 insurers matched deterministically
   - `ai_disambiguation` — AI resolved an ambiguous case (used by Plan 02)
   - `unmatched` — no insurer could be identified

2. **MatchResult** — Pydantic BaseModel with fields:
   - `insurer_ids: list[int]` — matched insurer IDs (may be empty for unmatched)
   - `confidence: float` — 0.0 to 1.0 match confidence (Field with ge=0.0, le=1.0)
   - `method: MatchMethod` — how the match was made
   - `reasoning: str` — brief human-readable explanation of match logic

Follow the same Pydantic style as `app/schemas/classification.py` (Field descriptions, Literal types).
  </action>
  <verify>
`python -c "from app.schemas.matching import MatchResult, MatchMethod; r = MatchResult(insurer_ids=[1], confidence=0.95, method='deterministic_single', reasoning='test'); print(r.model_dump_json())"` prints valid JSON.
  </verify>
  <done>MatchResult and MatchMethod importable and instantiable with all four method types.</done>
</task>

<task type="auto">
  <name>Task 2: Create InsurerMatcher deterministic service</name>
  <files>app/services/insurer_matcher.py</files>
  <action>
Create `app/services/insurer_matcher.py` with class `InsurerMatcher`:

**Text normalization (private helper):**
```python
def _normalize_text(text: str) -> str:
```
- Use `unicodedata.normalize('NFKD', text)` to decompose accents
- Filter out combining characters (`unicodedata.combining(c)`)
- Lowercase and strip whitespace
- This handles "SulAmerica" vs "SulAmerica" and case variations

**Deterministic matching (private method):**
```python
def _deterministic_match(self, article: dict, insurers: list[Insurer]) -> list[int]:
```
- Normalize article title + description into single `content` string
- For each insurer:
  - Normalize `insurer.name`
  - Skip names shorter than 4 characters for word-boundary matching (too many false positives for "Sul", "Amil" etc. — route these to AI in Plan 02)
  - Use `re.search(rf'\b{re.escape(name_norm)}\b', content)` for word-boundary matching
  - If insurer has `search_terms` (comma-separated string), normalize each term and check with same word-boundary regex
  - On first match (name or any search_term), append `insurer.id` and break to next insurer
- Return list of matched insurer IDs

**Short name handling:**
- Names with 3 or fewer normalized characters are SKIPPED by deterministic matching
- They will be handled by AI disambiguation in Plan 02
- Log a debug message when a short name is skipped

**Public match_article method:**
```python
def match_article(self, article: dict, insurers: list[Insurer]) -> MatchResult:
```
- Call `_deterministic_match(article, insurers)`
- If exactly 1 match: return MatchResult(insurer_ids=[id], confidence=0.95, method="deterministic_single", reasoning="Exact name match: {name}")
- If 2-3 matches: return MatchResult(insurer_ids=ids, confidence=0.85, method="deterministic_multi", reasoning="Found {N} name matches")
- If 0 or >3 matches: return MatchResult(insurer_ids=[], confidence=0.0, method="unmatched", reasoning="No clear deterministic match" or "Too many matches ({N}), needs AI")
  - IMPORTANT: For 0 or >3, the Plan 02 AI matcher will be wired in later. For now, return unmatched.

**Public match_batch method:**
```python
def match_batch(self, articles: list[dict], insurers: list[Insurer]) -> list[MatchResult]:
```
- Iterate articles, call `match_article` for each
- Use structlog for logging: log batch start/end with counts, log match stats summary (deterministic_single, deterministic_multi, unmatched counts)

**Constructor:**
- Initialize structlog logger: `self.logger = structlog.get_logger(__name__)`
- No Azure OpenAI client needed yet (Plan 02 adds it)

Use stdlib only: `unicodedata`, `re` — no new dependencies.
  </action>
  <verify>
Run a quick inline test:
```
python -c "
from app.services.insurer_matcher import InsurerMatcher
from app.schemas.matching import MatchResult

# Create mock insurer-like objects
class MockInsurer:
    def __init__(self, id, name, search_terms=None):
        self.id = id
        self.name = name
        self.search_terms = search_terms

matcher = InsurerMatcher()
insurers = [
    MockInsurer(1, 'Bradesco Saude', 'bradesco seguros'),
    MockInsurer(2, 'SulAmerica'),
    MockInsurer(3, 'Porto Seguro'),
]

# Test basic match
result = matcher.match_article({'title': 'Bradesco Saude anuncia novo plano', 'description': ''}, insurers)
assert result.method == 'deterministic_single'
assert result.insurer_ids == [1]

# Test multi match
result = matcher.match_article({'title': 'Bradesco Saude e Porto Seguro anunciam parceria', 'description': ''}, insurers)
assert result.method == 'deterministic_multi'
assert set(result.insurer_ids) == {1, 3}

# Test no match
result = matcher.match_article({'title': 'Regulacao do setor de seguros no Brasil', 'description': ''}, insurers)
assert result.method == 'unmatched'
assert result.insurer_ids == []

# Test accent normalization
result = matcher.match_article({'title': 'SulAmerica expande operacoes', 'description': ''}, insurers)
assert 2 in result.insurer_ids

print('All deterministic matcher tests passed')
"
```
  </verify>
  <done>InsurerMatcher deterministically matches articles to insurers by name/search_term with accent normalization and word-boundary safety. Short names (<4 chars) are skipped for AI. Batch method logs match statistics.</done>
</task>

</tasks>

<verification>
- `python -c "from app.schemas.matching import MatchResult, MatchMethod"` succeeds
- `python -c "from app.services.insurer_matcher import InsurerMatcher"` succeeds
- Inline test in Task 2 verify section passes all assertions
- No new dependencies added (uses stdlib unicodedata, re + existing structlog)
</verification>

<success_criteria>
- MatchResult schema exists with all four MatchMethod values
- InsurerMatcher.match_article returns correct MatchResult for single-match, multi-match, and unmatched cases
- Portuguese accent normalization works (accented and unaccented names both match)
- Word-boundary matching prevents "Sul" from matching inside "consulta"
- Short insurer names (<4 chars) are routed to unmatched (AI handles them in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/11-insurer-matching-pipeline/11-01-SUMMARY.md`
</output>
