---
phase: 05-professional-reporting
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - app/services/reporter.py
autonomous: true

must_haves:
  truths:
    - "ReportService uses professional template for generate_professional_report()"
    - "ReportService integrates ExecutiveSummarizer for AI summaries"
    - "ReportService integrates ReportArchiver for storage"
    - "Market context and recommendations sections populated"
    - "Existing generate_report() method preserved for backward compatibility"
  artifacts:
    - path: "app/services/reporter.py"
      provides: "Enhanced report generation with professional template"
      contains: "generate_professional_report"
  key_links:
    - from: "app/services/reporter.py"
      to: "app/templates/report_professional.html"
      via: "get_template('report_professional.html')"
      pattern: "report_professional"
    - from: "app/services/reporter.py"
      to: "app/services/executive_summarizer.py"
      via: "self.summarizer.generate_executive_summary"
      pattern: "ExecutiveSummarizer"
    - from: "app/services/reporter.py"
      to: "app/services/report_archiver.py"
      via: "self.archiver.save_report"
      pattern: "ReportArchiver"
---

<objective>
Enhance ReportService with professional template integration, AI summaries, and archival.

Purpose: Wire together the professional template, executive summarizer, and archiver into a cohesive report generation flow.
Output: Enhanced ReportService with generate_professional_report() method.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-professional-reporting/05-RESEARCH.md

Prior plan outputs (must exist):
@app/templates/report_professional.html (from 05-01)
@app/services/executive_summarizer.py (from 05-02)
@app/services/report_archiver.py (from 05-03)
@app/services/reporter.py (existing - to enhance)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance ReportService with professional report generation</name>
  <files>app/services/reporter.py</files>
  <action>
Read the existing `app/services/reporter.py` and enhance it with professional report generation capabilities.

**Add these imports at the top:**
```python
from typing import Optional, Tuple
from app.services.executive_summarizer import ExecutiveSummarizer
from app.services.report_archiver import ReportArchiver
from app.schemas.report import KeyFinding, ReportContext
```

**Add these class attributes in __init__:**
```python
# Phase 5: Compose with new services
self.summarizer = ExecutiveSummarizer()
self.archiver = ReportArchiver()
```

**Add these new methods to ReportService:**

1. **generate_professional_report()** - Main method for comprehensive reports:
```python
def generate_professional_report(
    self,
    category: str,
    insurers: list[Insurer],
    report_date: Optional[datetime] = None,
    archive: bool = True,
    use_ai_summary: bool = True
) -> Tuple[str, Optional[Path]]:
    """
    Generate comprehensive professional HTML report.

    Creates Marsh-branded report with:
    - AI-generated executive summary
    - Key findings cards
    - Coverage summary table
    - Insurers grouped by status
    - Market context section
    - Strategic recommendations
    - Mobile responsive design

    Args:
        category: Insurer category (Health, Dental, Group Life)
        insurers: List of Insurer objects with loaded news_items
        report_date: Date for report (defaults to now)
        archive: Whether to save report to archive
        use_ai_summary: Whether to use Azure OpenAI for summary

    Returns:
        Tuple of (html_content, archive_path or None)
    """
    if report_date is None:
        report_date = datetime.now()

    # Group insurers by status
    insurers_by_status = self.get_insurers_by_status(insurers)
    status_counts = self.get_status_counts(insurers_by_status)

    # Generate AI executive summary
    if use_ai_summary:
        executive_summary_paragraph = self.summarizer.generate_executive_summary(
            category=category,
            insurers=insurers
        )
    else:
        executive_summary_paragraph = self._get_basic_summary(category, insurers, status_counts)

    # Generate key findings cards
    key_findings = self.summarizer.generate_key_findings(insurers_by_status)

    # Generate market context
    market_context = self._generate_market_context(category)

    # Generate strategic recommendations
    recommendations = self._generate_recommendations(insurers_by_status, category)

    # Prepare template context
    template_context = {
        "company_name": self.settings.company_name,
        "category": category,
        "report_date": report_date.strftime("%d de %B de %Y").replace(
            "January", "janeiro"
        ).replace(
            "February", "fevereiro"
        ).replace(
            "March", "marco"
        ).replace(
            "April", "abril"
        ).replace(
            "May", "maio"
        ).replace(
            "June", "junho"
        ).replace(
            "July", "julho"
        ).replace(
            "August", "agosto"
        ).replace(
            "September", "setembro"
        ).replace(
            "October", "outubro"
        ).replace(
            "November", "novembro"
        ).replace(
            "December", "dezembro"
        ),
        "generation_timestamp": datetime.now().strftime("%d/%m/%Y as %H:%M"),
        "total_insurers": len(insurers),
        "executive_summary_paragraph": executive_summary_paragraph,
        "key_findings": [
            {"severity": f.severity, "title": f.title, "description": f.description}
            for f in key_findings
        ],
        "insurers": insurers,
        "insurers_by_status": insurers_by_status,
        "status_counts": status_counts,
        "market_context_paragraph": market_context["paragraph"],
        "context_items": market_context.get("items", []),
        "recommendations": recommendations
    }

    # Render professional template
    template = self.env.get_template("report_professional.html")
    html = template.render(**template_context)

    # Archive if requested
    archive_path = None
    if archive:
        archive_path = self.archiver.save_report(
            html=html,
            category=category,
            report_date=report_date
        )

    return html, archive_path
```

2. **_generate_market_context()** - Template-based market context:
```python
def _generate_market_context(self, category: str) -> dict:
    """
    Generate market context section content.

    Returns template-based context items relevant to the category.
    Future enhancement: Can be driven by external data sources.

    Args:
        category: Report category

    Returns:
        Dict with 'paragraph' and optional 'items' list
    """
    # Category-specific context templates
    contexts = {
        "Health": {
            "paragraph": (
                "O mercado brasileiro de saude suplementar continua sob pressao regulatoria "
                "da ANS com novos indices de qualidade e limites de reajuste para planos individuais. "
                "O setor apresenta movimentos de consolidacao e verticalizacao entre operadoras."
            ),
            "items": [
                {"title": "Reajuste ANS 2025-2026", "description": "Planos individuais limitados a 6,06% de reajuste anual conforme determinacao da ANS."},
                {"title": "IDSS Qualidade", "description": "Indice de Desempenho da Saude Suplementar atualizado em dezembro de 2025."},
            ]
        },
        "Dental": {
            "paragraph": (
                "O segmento odontologico brasileiro mantem crescimento estavel com expansao "
                "de planos corporativos. O mercado apresenta forte concorrencia entre operadoras "
                "e movimentos de integracao vertical."
            ),
            "items": [
                {"title": "Expansao PME", "description": "Aumento na demanda por planos odontologicos em pequenas e medias empresas."},
            ]
        },
        "Group Life": {
            "paragraph": (
                "O mercado de seguro de vida em grupo apresenta estabilidade com foco em "
                "produtos de protecao para colaboradores. Novas regulamentacoes da SUSEP "
                "impactam a estruturacao de produtos."
            ),
            "items": [
                {"title": "Lei de Seguros", "description": "Nova Lei de Seguros (15.040/2024) em vigor desde dezembro de 2025."},
            ]
        }
    }

    return contexts.get(category, {
        "paragraph": f"Analise do mercado de {category} no Brasil.",
        "items": []
    })
```

3. **_generate_recommendations()** - Data-driven recommendations:
```python
def _generate_recommendations(
    self,
    insurers_by_status: dict[str, list[Insurer]],
    category: str
) -> list[str]:
    """
    Generate strategic recommendations based on insurer data.

    Creates actionable recommendations for Marsh executives.

    Args:
        insurers_by_status: Insurers grouped by status
        category: Report category

    Returns:
        List of recommendation strings in Portuguese
    """
    recommendations = []

    # Critical status recommendations
    critical = insurers_by_status.get("Critical", [])
    if critical:
        names = ", ".join([i.name for i in critical[:3]])
        recommendations.append(
            f"Monitorar de perto as seguradoras em situacao critica ({names}). "
            f"Avaliar exposicao de clientes e preparar planos de contingencia."
        )

    # Watch status recommendations
    watch = insurers_by_status.get("Watch", [])
    if watch:
        recommendations.append(
            f"Acompanhar desenvolvimentos das {len(watch)} seguradoras sob observacao. "
            f"Manter comunicacao proativa com clientes afetados."
        )

    # General recommendations based on status distribution
    total = sum(len(v) for v in insurers_by_status.values())
    stable_pct = len(insurers_by_status.get("Stable", [])) / max(total, 1) * 100

    if stable_pct > 70:
        recommendations.append(
            f"O mercado de {category} apresenta estabilidade geral. "
            f"Aproveitar o momento para renovacoes e novas colocacoes."
        )
    else:
        recommendations.append(
            f"Considerar diversificacao de carteira em {category} dado o cenario atual. "
            f"Avaliar alternativas para seguradoras em monitoramento."
        )

    # Category-specific recommendations
    if category == "Health":
        recommendations.append(
            "Utilizar dados do IDSS na comparacao entre operadoras. "
            "Comunicar aos clientes os indices de qualidade publicados pela ANS."
        )
    elif category == "Dental":
        recommendations.append(
            "Explorar oportunidades no segmento PME com pacotes competitivos. "
            "Destacar diferenciais de rede credenciada nas propostas."
        )
    elif category == "Group Life":
        recommendations.append(
            "Revisar clausulas contratuais conforme nova Lei de Seguros. "
            "Garantir conformidade com exigencias regulatorias atualizadas."
        )

    return recommendations[:5]  # Limit to 5 recommendations
```

4. **_get_basic_summary()** - Non-AI summary fallback:
```python
def _get_basic_summary(
    self,
    category: str,
    insurers: list[Insurer],
    status_counts: dict[str, int]
) -> str:
    """
    Generate basic summary without AI.

    Used when use_ai_summary=False or as fallback.

    Args:
        category: Report category
        insurers: List of insurers
        status_counts: Count per status

    Returns:
        Summary paragraph in Portuguese
    """
    total = len(insurers)
    critical = status_counts.get("Critical", 0)
    watch = status_counts.get("Watch", 0)

    if critical > 0:
        return (
            f"Este relatorio abrange {total} seguradoras na categoria {category}. "
            f"Identificamos {critical} em situacao critica e {watch} sob monitoramento ativo. "
            f"Recomenda-se atencao prioritaria aos casos destacados."
        )
    elif watch > 0:
        return (
            f"Este relatorio abrange {total} seguradoras na categoria {category}. "
            f"Identificamos {watch} seguradoras sob monitoramento ativo. "
            f"O mercado apresenta estabilidade com pontos de atencao especificos."
        )
    else:
        return (
            f"Este relatorio abrange {total} seguradoras na categoria {category}. "
            f"O mercado apresenta estabilidade geral no periodo analisado."
        )
```

5. **generate_professional_report_from_db()** - Database integration:
```python
def generate_professional_report_from_db(
    self,
    category: str,
    run_id: int,
    db_session: Session,
    archive: bool = True,
    use_ai_summary: bool = True
) -> Tuple[str, Optional[Path]]:
    """
    Generate professional report for a specific run from database.

    Loads insurers and their news items for the specified run,
    then generates the professional HTML report.

    Args:
        category: Insurer category to filter by
        run_id: Run ID to generate report for
        db_session: Database session
        archive: Whether to save report to archive
        use_ai_summary: Whether to use Azure OpenAI for summary

    Returns:
        Tuple of (html_content, archive_path or None)

    Raises:
        ValueError: If run not found
    """
    # Verify run exists
    run = db_session.query(Run).filter(Run.id == run_id).first()
    if not run:
        raise ValueError(f"Run {run_id} not found")

    # Load insurers with their news items for this run
    insurers = (
        db_session.query(Insurer)
        .filter(
            Insurer.category == category,
            Insurer.enabled == True
        )
        .join(NewsItem, NewsItem.insurer_id == Insurer.id)
        .filter(NewsItem.run_id == run_id)
        .distinct()
        .all()
    )

    # Load news items for each insurer
    for insurer in insurers:
        insurer.news_items = (
            db_session.query(NewsItem)
            .filter(
                NewsItem.insurer_id == insurer.id,
                NewsItem.run_id == run_id
            )
            .all()
        )

    return self.generate_professional_report(
        category=category,
        insurers=insurers,
        report_date=run.started_at,
        archive=archive,
        use_ai_summary=use_ai_summary
    )
```

**IMPORTANT:** Keep all existing methods (generate_report, generate_report_from_db, preview_template) unchanged for backward compatibility.
  </action>
  <verify>
Has new method: `grep -c "def generate_professional_report" app/services/reporter.py` returns >= 2
Has ExecutiveSummarizer: `grep -c "ExecutiveSummarizer\|self.summarizer" app/services/reporter.py` returns >= 2
Has ReportArchiver: `grep -c "ReportArchiver\|self.archiver" app/services/reporter.py` returns >= 2
Has market context: `grep -c "_generate_market_context" app/services/reporter.py` returns >= 2
Has recommendations: `grep -c "_generate_recommendations" app/services/reporter.py` returns >= 2
Preserves old method: `grep -c "def generate_report\b" app/services/reporter.py` returns >= 1
  </verify>
  <done>
ReportService enhanced with:
- generate_professional_report() using professional template
- ExecutiveSummarizer integration for AI summaries
- ReportArchiver integration for storage
- Market context generation by category
- Strategic recommendations generation
- Database integration via generate_professional_report_from_db()
- Backward compatibility with existing methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Add category indicator mapping to template context</name>
  <files>app/services/reporter.py</files>
  <action>
Add a helper method to map category indicators to Portuguese labels. This is used by the template to display human-readable indicator badges.

Add this method to ReportService:

```python
@staticmethod
def get_indicator_label(indicator: str) -> str:
    """
    Map category indicator code to Portuguese label.

    Args:
        indicator: Indicator code from classification

    Returns:
        Portuguese label for display
    """
    labels = {
        "regulatory_action": "Acao Regulatoria",
        "financial_crisis": "Crise Financeira",
        "leadership_change": "Mudanca de Lideranca",
        "merger_acquisition": "Fusao/Aquisicao",
        "network_change": "Mudanca de Rede",
        "customer_complaints": "Reclamacoes",
        "rate_increase": "Aumento de Preco",
        "market_expansion": "Expansao",
        "partnership": "Parceria",
        "innovation": "Inovacao"
    }
    return labels.get(indicator, indicator)
```

Also add a Jinja2 custom filter in __init__:

```python
# Add custom filter for indicator labels
self.env.filters['indicator_label'] = self.get_indicator_label
```

Update the template context preparation in generate_professional_report() to ensure news items have parsed category_indicators:

```python
# Ensure category_indicators are parsed for template
for insurer in insurers:
    for news in insurer.news_items:
        if news.category_indicators and isinstance(news.category_indicators, str):
            news._parsed_indicators = [
                ind.strip() for ind in news.category_indicators.split(",")
                if ind.strip()
            ]
        else:
            news._parsed_indicators = news.category_indicators or []
```

This allows the template to use `{{ indicator|indicator_label }}` for displaying labels.
  </action>
  <verify>
Has indicator mapping: `grep -c "get_indicator_label\|indicator_label" app/services/reporter.py` returns >= 3
Has custom filter: `grep -c "env.filters" app/services/reporter.py` returns >= 1
  </verify>
  <done>
Indicator label mapping added with:
- get_indicator_label() static method for Portuguese labels
- Jinja2 custom filter for template usage
- Category indicator parsing in template context preparation
  </done>
</task>

</tasks>

<verification>
1. Service imports: `python -c "from app.services.reporter import ReportService"`
2. New method exists: `python -c "from app.services.reporter import ReportService; r = ReportService(); print(hasattr(r, 'generate_professional_report'))"`
3. Summarizer initialized: `python -c "from app.services.reporter import ReportService; r = ReportService(); print(hasattr(r, 'summarizer'))"`
4. Archiver initialized: `python -c "from app.services.reporter import ReportService; r = ReportService(); print(hasattr(r, 'archiver'))"`
</verification>

<success_criteria>
- ReportService instantiates with summarizer and archiver
- generate_professional_report() method exists and has correct signature
- Market context and recommendations methods generate valid content
- Existing methods still work (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/05-professional-reporting/05-04-SUMMARY.md`
</output>
