---
phase: 05-professional-reporting
plan: 05
type: execute
wave: 3
depends_on: ["05-04"]
files_modified:
  - app/routers/reports.py
  - app/main.py
autonomous: false

must_haves:
  truths:
    - "Admin can browse historical reports via GET /api/reports/archive"
    - "Admin can view specific report via GET /api/reports/archive/{date}/{filename}"
    - "Admin can filter reports by date range and category"
    - "API returns proper error handling for missing reports"
  artifacts:
    - path: "app/routers/reports.py"
      provides: "Report archive browsing API endpoints"
      min_lines: 60
      contains: "APIRouter"
    - path: "app/main.py"
      provides: "Router registration"
      contains: "reports.router"
  key_links:
    - from: "app/routers/reports.py"
      to: "app/services/report_archiver.py"
      via: "ReportArchiver"
      pattern: "browse_reports"
    - from: "app/main.py"
      to: "app/routers/reports.py"
      via: "include_router"
      pattern: "reports"
---

<objective>
Create API endpoints for browsing and viewing archived reports.

Purpose: Enable admin interface to browse historical reports by date and category (REPT-13).
Output: REST API endpoints for report archive access.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-professional-reporting/05-RESEARCH.md

Prior plan outputs:
@app/services/report_archiver.py (from 05-03)
@app/services/reporter.py (from 05-04)
@app/routers/runs.py (reference for router patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reports router with archive browsing endpoints</name>
  <files>app/routers/reports.py</files>
  <action>
Create `app/routers/reports.py` with archive browsing API endpoints.

```python
"""
Report archive browsing API endpoints.

Provides REST API for browsing and retrieving archived HTML reports.
"""
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, HTTPException, Query
from fastapi.responses import HTMLResponse
from pydantic import BaseModel

from app.services.report_archiver import ReportArchiver

router = APIRouter(prefix="/reports", tags=["Reports"])


class ArchivedReport(BaseModel):
    """Schema for archived report metadata."""
    date: str
    category: str
    filename: str
    timestamp: str
    path: str
    size_kb: int


class ArchiveBrowseResponse(BaseModel):
    """Response schema for archive browsing."""
    total: int
    reports: list[ArchivedReport]


class AvailableDatesResponse(BaseModel):
    """Response schema for available dates."""
    dates: list[str]


@router.get("/archive", response_model=ArchiveBrowseResponse)
async def browse_archived_reports(
    start_date: Optional[str] = Query(
        None,
        description="Filter from date (YYYY-MM-DD)",
        example="2026-02-01"
    ),
    end_date: Optional[str] = Query(
        None,
        description="Filter until date (YYYY-MM-DD)",
        example="2026-02-28"
    ),
    category: Optional[str] = Query(
        None,
        description="Filter by category",
        example="Health"
    ),
    limit: int = Query(
        50,
        ge=1,
        le=200,
        description="Maximum reports to return"
    )
) -> ArchiveBrowseResponse:
    """
    Browse archived reports with optional filtering.

    Returns list of reports sorted by date descending (newest first).

    - **start_date**: Filter reports from this date (inclusive)
    - **end_date**: Filter reports until this date (inclusive)
    - **category**: Filter by category (Health, Dental, Group Life)
    - **limit**: Maximum number of reports to return (1-200)
    """
    archiver = ReportArchiver()

    # Parse date strings
    start = None
    end = None

    if start_date:
        try:
            start = datetime.fromisoformat(start_date)
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid start_date format: {start_date}. Use YYYY-MM-DD."
            )

    if end_date:
        try:
            end = datetime.fromisoformat(end_date)
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid end_date format: {end_date}. Use YYYY-MM-DD."
            )

    reports = archiver.browse_reports(
        start_date=start,
        end_date=end,
        category=category,
        limit=limit
    )

    return ArchiveBrowseResponse(
        total=len(reports),
        reports=[ArchivedReport(**r) for r in reports]
    )


@router.get("/archive/dates", response_model=AvailableDatesResponse)
async def get_available_dates(
    category: Optional[str] = Query(
        None,
        description="Filter by category",
        example="Health"
    ),
    limit: int = Query(
        30,
        ge=1,
        le=90,
        description="Maximum dates to return"
    )
) -> AvailableDatesResponse:
    """
    Get list of dates that have archived reports.

    Useful for calendar-based browsing UI.

    - **category**: Filter by category (optional)
    - **limit**: Maximum dates to return (1-90)
    """
    archiver = ReportArchiver()

    dates = archiver.get_dates_with_reports(
        category=category,
        limit=limit
    )

    return AvailableDatesResponse(dates=dates)


@router.get(
    "/archive/{date}/{filename}",
    response_class=HTMLResponse,
    responses={
        200: {
            "content": {"text/html": {}},
            "description": "HTML report content"
        },
        404: {
            "description": "Report not found"
        }
    }
)
async def get_archived_report(
    date: str,
    filename: str
) -> HTMLResponse:
    """
    Retrieve a specific archived report.

    - **date**: Report date in YYYY-MM-DD format
    - **filename**: Report filename (e.g., health_14-30-00.html)

    Returns the raw HTML content of the report.
    """
    # Validate date format
    try:
        datetime.fromisoformat(date)
    except ValueError:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid date format: {date}. Use YYYY-MM-DD."
        )

    archiver = ReportArchiver()

    html = archiver.get_report(date=date, filename=filename)

    if html is None:
        raise HTTPException(
            status_code=404,
            detail=f"Report not found: {date}/{filename}"
        )

    return HTMLResponse(content=html)


@router.get("/preview")
async def preview_professional_report() -> HTMLResponse:
    """
    Generate a preview of the professional report template with sample data.

    Useful for testing template rendering without database data.
    """
    from app.services.reporter import ReportService
    from app.models.insurer import Insurer
    from app.models.news_item import NewsItem

    service = ReportService()

    # Create mock insurers with news for preview
    critical_insurer = Insurer(
        id=1,
        ans_code="123456",
        name="Seguradora Exemplo Critica",
        cnpj="12.345.678/0001-90",
        category="Health",
        status="Critical"
    )
    critical_insurer.news_items = [
        NewsItem(
            id=1,
            title="Seguradora enfrenta problemas financeiros graves",
            source_name="Valor Economico",
            source_url="https://example.com/news1",
            published_at=datetime.now(),
            status="Critical",
            sentiment="negative",
            summary="Prejuizo significativo no ultimo trimestre. ANS abriu processo de fiscalizacao.",
            category_indicators="financial_crisis,regulatory_action"
        )
    ]

    watch_insurer = Insurer(
        id=2,
        ans_code="234567",
        name="Plano Saude Monitor",
        cnpj="23.456.789/0001-01",
        category="Health",
        status="Watch"
    )
    watch_insurer.news_items = [
        NewsItem(
            id=2,
            title="Reclamacoes aumentam no periodo",
            source_name="CQCS",
            source_url="https://example.com/news2",
            published_at=datetime.now(),
            status="Watch",
            sentiment="neutral",
            summary="Aumento de reclamacoes de clientes sobre autorizacoes.",
            category_indicators="customer_complaints"
        )
    ]

    stable_insurer = Insurer(
        id=3,
        ans_code="345678",
        name="Seguradora Estavel SA",
        cnpj="34.567.890/0001-12",
        category="Health",
        status="Stable"
    )
    stable_insurer.news_items = [
        NewsItem(
            id=3,
            title="Empresa anuncia expansao de rede",
            source_name="InfoMoney",
            source_url="https://example.com/news3",
            published_at=datetime.now(),
            status="Stable",
            sentiment="positive",
            summary="Nova parceria amplia rede credenciada em SP e RJ.",
            category_indicators="market_expansion,partnership"
        )
    ]

    mock_insurers = [critical_insurer, watch_insurer, stable_insurer]

    # Generate professional report without archiving
    html, _ = service.generate_professional_report(
        category="Health",
        insurers=mock_insurers,
        archive=False,
        use_ai_summary=False  # Use basic summary for preview
    )

    return HTMLResponse(content=html)
```
  </action>
  <verify>
File exists: `test -f app/routers/reports.py && echo "Router file exists"`
Has router: `grep -c "APIRouter" app/routers/reports.py` returns 1
Has browse endpoint: `grep -c "def browse_archived_reports" app/routers/reports.py` returns 1
Has get endpoint: `grep -c "def get_archived_report" app/routers/reports.py` returns 1
Has preview endpoint: `grep -c "def preview_professional_report" app/routers/reports.py` returns 1
  </verify>
  <done>
Reports router created with:
- GET /api/reports/archive - Browse reports with filtering
- GET /api/reports/archive/dates - Get available dates
- GET /api/reports/archive/{date}/{filename} - Get specific report
- GET /api/reports/preview - Preview template with sample data
  </done>
</task>

<task type="auto">
  <name>Task 2: Register reports router in main app</name>
  <files>app/main.py</files>
  <action>
Read existing `app/main.py` and add the reports router registration.

Add import:
```python
from app.routers import reports
```

Add router registration (after other router includes):
```python
app.include_router(reports.router, prefix="/api")
```

This enables the reports archive endpoints at:
- GET /api/reports/archive
- GET /api/reports/archive/dates
- GET /api/reports/archive/{date}/{filename}
- GET /api/reports/preview
  </action>
  <verify>
Has import: `grep -c "from app.routers import.*reports\|from app.routers import reports" app/main.py` returns >= 1
Has router: `grep -c "reports.router" app/main.py` returns >= 1
  </verify>
  <done>
Reports router registered in main app at /api/reports prefix.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete professional reporting system with:
1. Marsh-branded HTML template with responsive design
2. AI-powered executive summary generation
3. File-based report archival with date hierarchy
4. Enhanced ReportService with professional report generation
5. REST API for browsing historical reports
  </what-built>
  <how-to-verify>
1. Start the application: `python -m uvicorn app.main:app --reload`

2. Open browser to preview endpoint: http://localhost:8000/api/reports/preview
   - Verify Marsh branding (blue colors: #00263e, #0077c8)
   - Verify red confidential banner at top
   - Verify executive summary section with key findings cards
   - Verify coverage summary table
   - Verify insurers grouped by status (Critical, Watch, Stable)
   - Verify market context section
   - Verify strategic recommendations section
   - Verify footer with generation timestamp

3. Test mobile responsiveness:
   - Open browser developer tools (F12)
   - Toggle device toolbar (Ctrl+Shift+M)
   - Set viewport to 375px width (mobile)
   - Verify content stacks vertically
   - Verify no horizontal scrolling required
   - Verify text is readable at mobile size

4. Test archive API:
   - GET http://localhost:8000/api/reports/archive
   - Should return JSON: {"total": 0, "reports": []}
   - GET http://localhost:8000/api/reports/archive/dates
   - Should return JSON: {"dates": []}

5. Verify API documentation:
   - Open http://localhost:8000/docs
   - Confirm /api/reports endpoints are listed
   - Confirm request/response schemas documented
  </how-to-verify>
  <resume-signal>Type "approved" if report looks correct and matches Marsh branding, or describe any issues that need fixing</resume-signal>
</task>

</tasks>

<verification>
1. Router imports: `python -c "from app.routers.reports import router"`
2. App starts: `timeout 5 python -m uvicorn app.main:app --port 8001` (should not error)
3. Preview endpoint responds: `curl -s http://localhost:8000/api/reports/preview | head -20`
</verification>

<success_criteria>
- All API endpoints respond correctly
- Preview shows Marsh-branded professional report
- Mobile responsive design works at 600px breakpoint
- Archive browsing returns proper JSON responses
- Human verification confirms visual design matches reference
</success_criteria>

<output>
After completion, create `.planning/phases/05-professional-reporting/05-05-SUMMARY.md`
</output>
