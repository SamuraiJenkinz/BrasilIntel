---
phase: 07-scheduling-automation
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - app/routers/schedules.py
  - app/main.py
autonomous: true

must_haves:
  truths:
    - "Admin can view all scheduled jobs via GET /api/schedules"
    - "Admin can modify cron expression via PUT /api/schedules/{category}"
    - "Admin can enable/disable jobs via PUT /api/schedules/{category}"
    - "Admin can trigger manual run via POST /api/schedules/{category}/trigger"
    - "Scheduler starts on app startup and stops on shutdown"
    - "Next run time displayed for each category"
  artifacts:
    - path: "app/routers/schedules.py"
      provides: "Schedule management API endpoints"
      min_lines: 100
      exports: ["router"]
    - path: "app/main.py"
      provides: "Scheduler lifecycle integration"
      contains: "SchedulerService"
  key_links:
    - from: "app/routers/schedules.py"
      to: "app/services/scheduler_service.py"
      via: "SchedulerService import"
      pattern: "from app.services.scheduler_service import SchedulerService"
    - from: "app/main.py"
      to: "app/services/scheduler_service.py"
      via: "lifespan hooks"
      pattern: "scheduler_service.start"
    - from: "app/main.py"
      to: "app/routers/schedules.py"
      via: "router registration"
      pattern: "include_router.*schedules"
---

<objective>
Create the schedule management API endpoints and integrate the scheduler with FastAPI's lifespan.

Purpose: This provides admin control over scheduled jobs (view, modify, enable/disable, trigger) and ensures the scheduler starts/stops properly with the application lifecycle.

Output: Working API endpoints at /api/schedules for full schedule management, with scheduler automatically running when app starts.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-scheduling-automation/07-RESEARCH.md

# From Plan 01
@app/services/scheduler_service.py
@app/config.py

# From Plan 02
@app/schemas/schedule.py

# Existing patterns
@app/routers/runs.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schedule management router</name>
  <files>app/routers/schedules.py</files>
  <action>
Create app/routers/schedules.py with schedule management endpoints:

```python
"""
Schedule management router for BrasilIntel.

Provides endpoints to view, modify, and control scheduled category runs.
All times are in São Paulo timezone (America/Sao_Paulo).
"""
import logging
from fastapi import APIRouter, HTTPException

from app.services.scheduler_service import SchedulerService
from app.schemas.schedule import (
    ScheduleInfo,
    ScheduleUpdate,
    ScheduleList,
    ManualTriggerResponse,
    ScheduleHealthResponse,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/schedules", tags=["Schedules"])

VALID_CATEGORIES = ["Health", "Dental", "Group Life"]


def _validate_category(category: str) -> str:
    """Validate and normalize category name."""
    # Try exact match first
    if category in VALID_CATEGORIES:
        return category
    # Try case-insensitive match
    lower_map = {c.lower(): c for c in VALID_CATEGORIES}
    if category.lower() in lower_map:
        return lower_map[category.lower()]
    raise HTTPException(
        status_code=400,
        detail=f"Invalid category: {category}. Valid options: {VALID_CATEGORIES}"
    )


@router.get("", response_model=ScheduleList)
def list_schedules() -> ScheduleList:
    """
    List all scheduled category jobs.

    Returns schedule information for Health, Dental, and Group Life
    including next run time, enabled status, and cron expression.
    """
    scheduler = SchedulerService()
    schedules = scheduler.get_all_schedules()
    return ScheduleList(
        schedules=[ScheduleInfo(**s) for s in schedules],
        timezone="America/Sao_Paulo"
    )


@router.get("/health", response_model=ScheduleHealthResponse)
def scheduler_health() -> ScheduleHealthResponse:
    """
    Check scheduler health status.

    Returns whether scheduler is running, job count, and next scheduled jobs.
    """
    scheduler = SchedulerService()
    return scheduler.get_health_status()


@router.get("/{category}", response_model=ScheduleInfo)
def get_schedule(category: str) -> ScheduleInfo:
    """
    Get schedule for a specific category.

    Args:
        category: One of Health, Dental, or Group Life
    """
    category = _validate_category(category)
    scheduler = SchedulerService()
    schedule = scheduler.get_schedule(category)

    if not schedule:
        raise HTTPException(
            status_code=404,
            detail=f"No schedule found for category: {category}"
        )

    return ScheduleInfo(**schedule)


@router.put("/{category}", response_model=ScheduleInfo)
def update_schedule(category: str, update: ScheduleUpdate) -> ScheduleInfo:
    """
    Update schedule configuration for a category.

    Can modify:
    - hour/minute: Set specific daily run time
    - cron_expression: Full cron for custom schedules
    - enabled: Enable or disable the scheduled job

    All times are in São Paulo timezone.
    """
    category = _validate_category(category)
    scheduler = SchedulerService()

    try:
        # Handle enable/disable
        if update.enabled is not None:
            if update.enabled:
                scheduler.resume_job(category)
                logger.info(f"Enabled schedule for {category}")
            else:
                scheduler.pause_job(category)
                logger.info(f"Disabled schedule for {category}")

        # Handle time/cron changes
        if update.cron_expression or update.hour is not None or update.minute is not None:
            scheduler.update_schedule(
                category=category,
                hour=update.hour,
                minute=update.minute,
                cron_expression=update.cron_expression
            )
            logger.info(f"Updated schedule for {category}")

        schedule = scheduler.get_schedule(category)
        return ScheduleInfo(**schedule)

    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Failed to update schedule for {category}: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{category}/trigger", response_model=ManualTriggerResponse)
async def trigger_manual_run(category: str) -> ManualTriggerResponse:
    """
    Trigger an immediate run for a category.

    This bypasses the schedule and starts processing immediately.
    The run will be tracked with trigger_type='manual'.
    """
    category = _validate_category(category)
    scheduler = SchedulerService()

    try:
        await scheduler.trigger_now(category)
        return ManualTriggerResponse(
            status="triggered",
            category=category,
            message=f"Manual run triggered for {category}. Check /api/runs for status."
        )
    except Exception as e:
        logger.error(f"Failed to trigger manual run for {category}: {e}")
        return ManualTriggerResponse(
            status="error",
            category=category,
            message=str(e)
        )


@router.post("/{category}/pause", response_model=ScheduleInfo)
def pause_schedule(category: str) -> ScheduleInfo:
    """
    Pause scheduled runs for a category.

    The job remains registered but will not execute until resumed.
    """
    category = _validate_category(category)
    scheduler = SchedulerService()

    schedule = scheduler.pause_job(category)
    logger.info(f"Paused schedule for {category}")
    return ScheduleInfo(**schedule)


@router.post("/{category}/resume", response_model=ScheduleInfo)
def resume_schedule(category: str) -> ScheduleInfo:
    """
    Resume a paused schedule for a category.
    """
    category = _validate_category(category)
    scheduler = SchedulerService()

    schedule = scheduler.resume_job(category)
    logger.info(f"Resumed schedule for {category}")
    return ScheduleInfo(**schedule)
```
  </action>
  <verify>
```python
python -c "
from app.routers.schedules import router
print('Router prefix:', router.prefix)
routes = [r.path for r in router.routes]
print('Routes:', routes)
assert '' in routes or '/' in routes, 'Missing list endpoint'
assert '/{category}' in routes, 'Missing get/update endpoint'
assert '/{category}/trigger' in routes, 'Missing trigger endpoint'
print('All required routes present')
"
```
  </verify>
  <done>Schedule router created with list, get, update, trigger, pause, resume endpoints.</done>
</task>

<task type="auto">
  <name>Task 2: Add get_health_status method to SchedulerService</name>
  <files>app/services/scheduler_service.py</files>
  <action>
Add the get_health_status method to SchedulerService that the /health endpoint needs:

```python
def get_health_status(self) -> dict:
    """
    Get scheduler health status.

    Returns:
        Dict with scheduler_running, jobs_count, timezone, and next_jobs
    """
    jobs = self._scheduler.get_jobs() if self._scheduler else []

    next_jobs = []
    for job in jobs:
        if job.next_run_time:
            next_jobs.append({
                "job_id": job.id,
                "name": job.name,
                "next_run_time": job.next_run_time.isoformat(),
            })

    # Sort by next run time
    next_jobs.sort(key=lambda x: x["next_run_time"])

    return {
        "scheduler_running": self._scheduler.running if self._scheduler else False,
        "jobs_count": len(jobs),
        "timezone": str(self.SAO_PAULO_TZ),
        "next_jobs": next_jobs[:5],  # Top 5 upcoming jobs
    }
```

Also ensure the get_schedule method returns the cron_expression field:

```python
def get_schedule(self, category: str) -> Optional[dict]:
    """Get schedule info for a category."""
    job_id = self.get_job_id(category)
    job = self._scheduler.get_job(job_id)

    if job is None:
        return None

    # Extract cron expression from trigger
    cron_expr = str(job.trigger) if job.trigger else ""

    return {
        "category": category,
        "job_id": job_id,
        "enabled": job.next_run_time is not None,
        "next_run_time": job.next_run_time if job.next_run_time else None,
        "cron_expression": cron_expr,
        "last_run_time": None,  # TODO: Track from run history
        "last_run_status": None,
    }
```
  </action>
  <verify>
```python
python -c "
from app.services.scheduler_service import SchedulerService
svc = SchedulerService()
health = svc.get_health_status()
print('Health status:', health)
assert 'scheduler_running' in health
assert 'jobs_count' in health
print('Health status method works')
"
```
  </verify>
  <done>SchedulerService has get_health_status method returning scheduler status and next jobs.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate scheduler with FastAPI lifespan</name>
  <files>app/main.py</files>
  <action>
Update app/main.py to start/stop scheduler with the application:

1. Add import for SchedulerService:
```python
from app.services.scheduler_service import SchedulerService
```

2. Add import for the schedules router:
```python
from app.routers import insurers, import_export, runs, reports, schedules
```

3. Update the lifespan function to include scheduler lifecycle:
```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Application lifespan handler.

    Creates database tables on startup, starts the scheduler,
    yields control during app lifetime, and handles cleanup on shutdown.
    """
    # Startup: Create data directory and database tables
    os.makedirs("data", exist_ok=True)
    Base.metadata.create_all(bind=engine)

    # Start scheduler for automated category runs
    scheduler_service = SchedulerService()
    try:
        scheduler_service.start()
        logger.info("Scheduler started successfully")
    except Exception as e:
        logger.error(f"Failed to start scheduler: {e}")
        # Don't block app startup if scheduler fails

    yield

    # Shutdown: Stop scheduler gracefully
    try:
        scheduler_service.shutdown(wait=False)
        logger.info("Scheduler shutdown complete")
    except Exception as e:
        logger.error(f"Error during scheduler shutdown: {e}")
```

4. Register the schedules router:
```python
app.include_router(schedules.router)
```

5. Add logging import at the top if not present:
```python
import logging
logger = logging.getLogger(__name__)
```

6. Update the health check endpoint to include scheduler status:
   In the health_check function, add a scheduler check:
```python
# Check scheduler status
try:
    scheduler_service = SchedulerService()
    if scheduler_service._scheduler and scheduler_service._scheduler.running:
        checks["scheduler"] = {
            "status": "healthy",
            "message": f"Scheduler running with {len(scheduler_service._scheduler.get_jobs())} jobs"
        }
    else:
        checks["scheduler"] = {
            "status": "warning",
            "message": "Scheduler not running"
        }
        if overall_status == "healthy":
            overall_status = "degraded"
except Exception as e:
    checks["scheduler"] = {
        "status": "unhealthy",
        "message": f"Scheduler error: {str(e)}"
    }
    overall_status = "unhealthy"
```
  </action>
  <verify>
Start the app and verify scheduler starts:
```bash
# In one terminal, start the app (will see scheduler logs)
cd C:\BrasilIntel && python -m uvicorn app.main:app --port 8000

# In another terminal, test the endpoints
curl http://localhost:8000/api/health
curl http://localhost:8000/api/schedules
curl http://localhost:8000/api/schedules/health
```

Expected:
- /api/health shows scheduler: healthy
- /api/schedules returns list of 3 schedules (Health, Dental, Group Life)
- /api/schedules/health shows scheduler_running: true
  </verify>
  <done>Scheduler starts on app startup, stops on shutdown, health check includes scheduler status, and /api/schedules endpoints are registered.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Start the app: `python -m uvicorn app.main:app --port 8000`
2. Verify scheduler started in logs: "Scheduler started successfully"
3. Test endpoints:
   - GET /api/schedules - returns 3 schedules with next_run_time
   - GET /api/schedules/Health - returns Health schedule info
   - PUT /api/schedules/Health with {"enabled": false} - disables job
   - POST /api/schedules/Health/resume - re-enables job
   - GET /api/health - shows scheduler: healthy
</verification>

<success_criteria>
- /api/schedules endpoint returns all 3 category schedules
- /api/schedules/{category} returns individual schedule with next_run_time
- /api/schedules/{category} PUT updates cron/enabled status
- /api/schedules/{category}/trigger POST triggers immediate run
- /api/schedules/{category}/pause and /resume work correctly
- /api/schedules/health returns scheduler status
- Scheduler auto-starts on app startup
- Scheduler gracefully shuts down on app close
- /api/health includes scheduler status check
</success_criteria>

<output>
After completion, create `.planning/phases/07-scheduling-automation/07-03-SUMMARY.md`
</output>
