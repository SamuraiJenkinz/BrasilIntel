---
phase: 07-scheduling-automation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/schemas/schedule.py
  - app/models/run.py
  - app/schemas/run.py
autonomous: true

must_haves:
  truths:
    - "Schedule schemas define API contracts for schedule management"
    - "Run model tracks scheduled job metadata"
    - "RunRead schema includes scheduled tracking fields"
  artifacts:
    - path: "app/schemas/schedule.py"
      provides: "Pydantic schemas for schedule API"
      min_lines: 50
      exports: ["ScheduleInfo", "ScheduleUpdate", "ScheduleList"]
    - path: "app/models/run.py"
      provides: "Run model with scheduled tracking fields"
      contains: "scheduled_job_id"
    - path: "app/schemas/run.py"
      provides: "RunRead with scheduled fields"
      contains: "scheduled_job_id"
  key_links:
    - from: "app/schemas/schedule.py"
      to: "pydantic"
      via: "BaseModel inheritance"
      pattern: "class.*BaseModel"
---

<objective>
Create Pydantic schemas for the schedule management API and enhance Run model with scheduled job tracking.

Purpose: These schemas define the API contracts for schedule listing, updating, and control. The Run model enhancement allows tracking which runs came from scheduled jobs vs manual triggers.

Output: Complete schema definitions ready for API endpoints, and enhanced Run model for scheduled job tracking.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-scheduling-automation/07-RESEARCH.md

# Existing schemas to follow patterns from
@app/schemas/run.py
@app/schemas/delivery.py
@app/models/run.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schedule schemas</name>
  <files>app/schemas/schedule.py</files>
  <action>
Create app/schemas/schedule.py with Pydantic schemas for schedule management:

```python
"""
Pydantic schemas for schedule management API.

Defines request/response schemas for viewing and modifying scheduled jobs.
"""
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field, ConfigDict


class ScheduleInfo(BaseModel):
    """Response model for schedule information."""
    model_config = ConfigDict(from_attributes=True)

    category: str = Field(description="Product category: Health, Dental, or Group Life")
    job_id: str = Field(description="APScheduler job ID")
    enabled: bool = Field(description="Whether the scheduled job is active")
    next_run_time: Optional[datetime] = Field(
        None,
        description="Next scheduled execution time (São Paulo timezone)"
    )
    cron_expression: str = Field(
        description="Cron expression for the schedule"
    )
    last_run_time: Optional[datetime] = Field(
        None,
        description="Last execution time"
    )
    last_run_status: Optional[str] = Field(
        None,
        description="Status of last run: completed, failed"
    )


class ScheduleUpdate(BaseModel):
    """Request model for updating a schedule."""
    hour: Optional[int] = Field(
        None,
        ge=0,
        le=23,
        description="Hour to run (0-23, São Paulo time)"
    )
    minute: Optional[int] = Field(
        None,
        ge=0,
        le=59,
        description="Minute to run (0-59)"
    )
    cron_expression: Optional[str] = Field(
        None,
        description="Full cron expression (overrides hour/minute if provided)"
    )
    enabled: Optional[bool] = Field(
        None,
        description="Enable or disable the scheduled job"
    )


class ScheduleList(BaseModel):
    """Response model for list of all schedules."""
    schedules: list[ScheduleInfo]
    timezone: str = Field(
        default="America/Sao_Paulo",
        description="Timezone used for all schedule times"
    )


class ManualTriggerResponse(BaseModel):
    """Response model for manual trigger request."""
    status: str = Field(description="triggered or error")
    category: str = Field(description="Category that was triggered")
    message: str = Field(description="Status message")


class ScheduleHealthResponse(BaseModel):
    """Response model for scheduler health check."""
    scheduler_running: bool = Field(description="Whether scheduler is active")
    jobs_count: int = Field(description="Number of registered jobs")
    timezone: str = Field(description="Configured timezone")
    next_jobs: list[dict] = Field(
        default_factory=list,
        description="Next scheduled jobs with times"
    )
```

Follow existing schema patterns from delivery.py (use Field descriptions, ConfigDict).
  </action>
  <verify>
```python
python -c "
from app.schemas.schedule import ScheduleInfo, ScheduleUpdate, ScheduleList
print('ScheduleInfo fields:', list(ScheduleInfo.model_fields.keys()))
print('ScheduleUpdate fields:', list(ScheduleUpdate.model_fields.keys()))
print('ScheduleList fields:', list(ScheduleList.model_fields.keys()))
"
```
Expected: Lists all field names for each schema
  </verify>
  <done>Schedule schemas created with ScheduleInfo, ScheduleUpdate, ScheduleList, ManualTriggerResponse, and ScheduleHealthResponse.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance Run model with scheduled tracking</name>
  <files>app/models/run.py</files>
  <action>
Add scheduled job tracking fields to Run model in app/models/run.py:

1. Add new columns after the existing fields (before relationships):
```python
# Scheduled job tracking (Phase 7)
scheduled_job_id = Column(String(100), nullable=True)  # APScheduler job ID that triggered this run
scheduled_time = Column(DateTime, nullable=True)  # Originally scheduled time
actual_start_delay_seconds = Column(Integer, nullable=True)  # Delay from scheduled to actual start
```

2. The trigger_type field already exists ("scheduled" or "manual") - no changes needed there.

3. Update __repr__ to include scheduled_job_id if present:
```python
def __repr__(self) -> str:
    email_info = f", email='{self.email_status}'" if self.email_status else ""
    sched_info = f", job='{self.scheduled_job_id}'" if self.scheduled_job_id else ""
    return f"<Run(id={self.id}, category='{self.category}', status='{self.status}'{email_info}{sched_info})>"
```

NOTE: These are nullable columns with no default, so SQLite will auto-migrate when the app restarts. No explicit migration needed.
  </action>
  <verify>
```python
python -c "
from app.models.run import Run
from sqlalchemy import inspect
mapper = inspect(Run)
columns = [c.name for c in mapper.columns]
print('Run columns:', columns)
assert 'scheduled_job_id' in columns, 'Missing scheduled_job_id'
assert 'scheduled_time' in columns, 'Missing scheduled_time'
print('All scheduled tracking columns present')
"
```
  </verify>
  <done>Run model has scheduled_job_id, scheduled_time, and actual_start_delay_seconds columns.</done>
</task>

<task type="auto">
  <name>Task 3: Update RunRead schema with scheduled fields</name>
  <files>app/schemas/run.py</files>
  <action>
Update RunRead schema in app/schemas/run.py to include scheduled tracking fields:

1. Add new fields to RunRead class:
```python
# Scheduled job tracking (Phase 7)
scheduled_job_id: Optional[str] = None
scheduled_time: Optional[datetime] = None
actual_start_delay_seconds: Optional[int] = None
```

2. Also add the delivery tracking fields that were added in Phase 6 but may be missing from schema:
```python
# Delivery tracking (Phase 6)
email_status: Optional[str] = None
email_sent_at: Optional[datetime] = None
email_recipients_count: int = 0
email_error_message: Optional[str] = None
pdf_generated: bool = False
pdf_size_bytes: Optional[int] = None
critical_alert_sent: bool = False
critical_alert_sent_at: Optional[datetime] = None
critical_insurers_count: int = 0
```

The final RunRead class should have all fields from the Run model for complete API responses.
  </action>
  <verify>
```python
python -c "
from app.schemas.run import RunRead
fields = list(RunRead.model_fields.keys())
print('RunRead fields:', fields)
assert 'scheduled_job_id' in fields, 'Missing scheduled_job_id'
assert 'scheduled_time' in fields, 'Missing scheduled_time'
assert 'email_status' in fields, 'Missing email_status'
print('All required fields present')
"
```
  </verify>
  <done>RunRead schema includes all scheduled tracking and delivery tracking fields.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `python -c "from app.schemas.schedule import *"` imports without error
2. `python -c "from app.models.run import Run; print(Run.__table__.columns.keys())"` shows all columns
3. `python -c "from app.schemas.run import RunRead; print(list(RunRead.model_fields.keys()))"` shows all fields
</verification>

<success_criteria>
- app/schemas/schedule.py exists with ScheduleInfo, ScheduleUpdate, ScheduleList schemas
- Run model has scheduled_job_id, scheduled_time, actual_start_delay_seconds columns
- RunRead schema includes all scheduled and delivery tracking fields
- All schemas follow existing project patterns (Field descriptions, ConfigDict)
</success_criteria>

<output>
After completion, create `.planning/phases/07-scheduling-automation/07-02-SUMMARY.md`
</output>
