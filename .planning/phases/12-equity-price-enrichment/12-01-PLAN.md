---
phase: 12-equity-price-enrichment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/equity_client.py
  - app/routers/runs.py
autonomous: true

must_haves:
  truths:
    - "EquityClient can fetch price data for a B3 ticker from the MMC Core API equity endpoint"
    - "EquityClient returns None on any failure without crashing the caller"
    - "Pipeline run attaches equity price data to NewsItems that match enabled EquityTicker mappings"
    - "Duplicate ticker lookups within a single pipeline run are cached (one API call per unique ticker)"
    - "ApiEvent records are created for each equity price fetch (success or failure)"
  artifacts:
    - path: "app/services/equity_client.py"
      provides: "MMC Core API equity price client with retry, fallback field names, ApiEvent logging"
      contains: "class EquityPriceClient"
    - path: "app/routers/runs.py"
      provides: "Pipeline equity enrichment step integrated after classification"
      contains: "_enrich_equity_data"
  key_links:
    - from: "app/services/equity_client.py"
      to: "app/config.py"
      via: "get_settings() for mmc_api_base_url and mmc_api_key"
      pattern: "get_settings.*mmc_api"
    - from: "app/services/equity_client.py"
      to: "app/models/api_event.py"
      via: "_record_event with ApiEventType.EQUITY_FETCH"
      pattern: "ApiEventType\\.EQUITY_FETCH"
    - from: "app/routers/runs.py"
      to: "app/services/equity_client.py"
      via: "EquityPriceClient import and get_price() calls"
      pattern: "EquityPriceClient"
    - from: "app/routers/runs.py"
      to: "app/models/equity_ticker.py"
      via: "EquityTicker query for enabled ticker mappings"
      pattern: "EquityTicker.*enabled"
---

<objective>
Port the EquityPriceClient from MDInsights and integrate equity price enrichment into the BrasilIntel Factiva pipeline.

Purpose: Establishes the data flow that fetches real-time B3 equity prices for tracked Brazilian insurers during each pipeline run, making price data available for report rendering in subsequent plans.

Output: Two files — a new equity_client.py service and an updated runs.py with equity enrichment step.
</objective>

<execution_context>
@C:\Users\taylo\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\taylo\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-equity-price-enrichment/12-CONTEXT.md
@.planning/phases/12-equity-price-enrichment/12-RESEARCH.md
@.planning/phases/09-enterprise-api-foundation/09-02-SUMMARY.md

Key reference: MDInsights EquityPriceClient at C:\BrasilIntel\mdinsights\app\collectors\equity.py
Key reference: Current pipeline at app/routers/runs.py (function _execute_factiva_pipeline)

Existing infrastructure (Phase 9):
- EquityTicker model: app/models/equity_ticker.py (entity_name, ticker, exchange, enabled)
- ApiEvent model: app/models/api_event.py (ApiEventType.EQUITY_FETCH, EQUITY_FALLBACK)
- Config: app/config.py (mmc_api_base_url, mmc_api_key, is_mmc_api_key_configured)
- Database: app/database.py (SessionLocal)

BrasilIntel entities are structured insurer objects in NewsItem — enrichment must extract insurer name from entity dict, not free-text.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port EquityPriceClient from MDInsights</name>
  <files>app/services/equity_client.py</files>
  <action>
Create app/services/equity_client.py by porting from C:\BrasilIntel\mdinsights\app\collectors\equity.py with these adaptations:

1. Copy the entire EquityPriceClient class (keep the name EquityPriceClient for consistency with MDInsights)
2. Update docstrings: "MDInsights" → "BrasilIntel", phase references to Phase 12
3. Change default exchange in get_price() from "NYSE" to "BVMF" (Brazilian B3 exchange)
4. Keep all existing patterns intact:
   - httpx + tenacity retry (2 attempts, exponential backoff)
   - X-Api-Key header authentication via get_settings()
   - Response field name fallbacks: price/lastPrice/last, change/priceChange/netChange, changePct/percentChange/pctChange
   - _record_event() with isolated SessionLocal for ApiEvent logging
   - Returns None on any failure, never raises exceptions
   - is_configured() guard checking base_url and api_key

Do NOT change any logic — this is a direct port with only naming and default exchange changes.
  </action>
  <verify>
- File exists at app/services/equity_client.py
- Contains class EquityPriceClient with get_price(), is_configured(), _fetch_price(), _record_event(), _build_headers()
- Default exchange is "BVMF" (not "NYSE")
- Imports resolve: httpx, structlog, tenacity, app.config, app.database, app.models.api_event
- python -c "from app.services.equity_client import EquityPriceClient; print('OK')" succeeds
  </verify>
  <done>EquityPriceClient service exists, importable, and follows the proven MDInsights pattern with BVMF default exchange</done>
</task>

<task type="auto">
  <name>Task 2: Integrate equity enrichment into Factiva pipeline</name>
  <files>app/routers/runs.py</files>
  <action>
Add equity price enrichment to the _execute_factiva_pipeline function in app/routers/runs.py.

1. Add imports at top of file:
   - from app.services.equity_client import EquityPriceClient
   - from app.models.equity_ticker import EquityTicker

2. Create a new helper function _enrich_equity_data() that:
   - Takes parameters: (news_items: list of NewsItem ORM objects, run_id: int, db: Session)
   - Returns: dict mapping insurer_id -> list of equity price dicts
   - Implementation:
     a. Load all enabled EquityTicker rows from DB into ticker_map (entity_name.lower() → EquityTicker row)
     b. If ticker_map is empty, return empty dict immediately (no tickers configured = skip enrichment)
     c. Check if EquityPriceClient is configured (is_configured()), if not, log warning and return empty dict
     d. Build a set of unique insurer_ids from news_items
     e. For each unique insurer_id, query the Insurer name from DB
     f. Match insurer name (case-insensitive) against ticker_map
     g. Fetch price via EquityPriceClient.get_price(ticker, exchange, run_id) with caching:
        - Use fetched_prices dict keyed by "TICKER:EXCHANGE" to avoid duplicate API calls
     h. Return dict: {insurer_id: [price_dict, ...]} for insurers that have ticker matches

3. Call _enrich_equity_data() in _execute_factiva_pipeline AFTER the "Store matched articles + classify" loop and db.commit(), but BEFORE _generate_and_send_report(). Insert the enrichment step between lines ~232 (after db.commit of news items) and ~234 (before critical alerts check):
   ```python
   # Equity price enrichment
   logger.info("Enriching with equity price data...")
   all_run_items = db.query(NewsItem).filter(NewsItem.run_id == run.id).all()
   equity_data = _enrich_equity_data(all_run_items, run.id, db)
   logger.info(f"Equity enrichment: {len(equity_data)} insurers with price data")
   ```

4. Pass equity_data through to _generate_and_send_report() — add equity_data parameter to that function signature. Inside _generate_and_send_report, pass equity_data to report_service.generate_professional_report_from_db() as a new keyword argument. (The reporter will use it in Plan 12-03, for now just thread it through without error.)

IMPORTANT: The enrichment function must handle the case where EquityClient is not configured (no MMC credentials) gracefully — return empty dict, log a message, and let the pipeline continue normally. This is the expected state for development environments.
  </action>
  <verify>
- _enrich_equity_data function exists in runs.py
- EquityPriceClient and EquityTicker are imported
- Pipeline still works without MMC credentials (equity enrichment returns empty, pipeline continues)
- Price caching logic uses "TICKER:EXCHANGE" key to prevent duplicate API calls
- equity_data is threaded through to _generate_and_send_report
- python -c "from app.routers.runs import router; print('OK')" succeeds (no import errors)
  </verify>
  <done>Pipeline enriches news items with equity price data for insurers that have configured ticker mappings, with per-run caching and graceful degradation</done>
</task>

</tasks>

<verification>
1. app/services/equity_client.py exists and is importable
2. EquityPriceClient.get_price() defaults to exchange="BVMF"
3. app/routers/runs.py imports EquityPriceClient and EquityTicker
4. _enrich_equity_data function exists and handles unconfigured state gracefully
5. equity_data dict is passed through to report generation (even if empty)
6. No import errors when loading the FastAPI app
</verification>

<success_criteria>
- EquityPriceClient service ported from MDInsights with BVMF default
- Pipeline calls equity enrichment after classification, before report generation
- Duplicate ticker prices cached within a single run
- Graceful degradation when MMC API is unconfigured or unavailable
- No breaking changes to existing pipeline behavior
</success_criteria>

<output>
After completion, create `.planning/phases/12-equity-price-enrichment/12-01-SUMMARY.md`
</output>
